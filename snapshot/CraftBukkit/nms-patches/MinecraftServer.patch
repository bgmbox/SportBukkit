--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -35,12 +35,27 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+// CraftBukkit start
+import jline.console.ConsoleReader;
+import joptsimple.OptionSet;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.Main;
+import org.bukkit.event.EventBody;
+import org.bukkit.event.server.ServerSuspendEvent;
+// CraftBukkit end
+
+// SportBukkit start
+import java.time.Instant;
+import java.util.Deque;
+// SportBukkit end
 
 public abstract class MinecraftServer implements ICommandListener, Runnable, IAsyncTaskHandler, IMojangStatistics {
 
@@ -95,22 +110,86 @@
     private final UserCache Y;
     private long Z;
     protected final Queue<FutureTask<?>> j = Queues.newArrayDeque();
+    public final Deque<FutureTask<?>> taskQueue = (Deque<FutureTask<?>>) j; // SportBukkit - alias and downcast
     private Thread serverThread;
+    void setLastTickStart(long millis) { ab = millis; } // SportBukkit - alias
     private long ab = aw();
 
-    public MinecraftServer(File file, Proxy proxy, DataConverterManager dataconvertermanager, YggdrasilAuthenticationService yggdrasilauthenticationservice, MinecraftSessionService minecraftsessionservice, GameProfileRepository gameprofilerepository, UserCache usercache) {
+    // CraftBukkit start
+    public List<WorldServer> worlds = new ArrayList<WorldServer>();
+    public org.bukkit.craftbukkit.CraftServer server;
+    public OptionSet options;
+    public org.bukkit.command.ConsoleCommandSender console;
+    public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
+    public ConsoleReader reader;
+    public static int currentTick = (int) (System.currentTimeMillis() / 50);
+    public final Thread primaryThread;
+    //public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>(); SportBukkit - use Mojang's task queue
+    public int autosavePeriod;
+    // CraftBukkit end
+    // SportBukkit start
+    private static final int TPS = 20;
+    private static final int TICK_TIME = 1000000000 / TPS;
+    private static final int SAMPLE_INTERVAL = 100;
+    public final double[] recentTps = new double[3];
+
+    protected boolean abnormalTermination;
+    // Sportbukkit end
+
+    // SportBukkit start
+    private final AtomicBoolean suspended = new AtomicBoolean(false);
+    private @Nullable Instant suspendedAt;
+    private int interruptions;
+    protected Thread watchdogThread;
+    // SportBukkit end
+
+    public MinecraftServer(OptionSet options, Proxy proxy, DataConverterManager dataconvertermanager, YggdrasilAuthenticationService yggdrasilauthenticationservice, MinecraftSessionService minecraftsessionservice, GameProfileRepository gameprofilerepository, UserCache usercache) {
         this.e = proxy;
         this.V = yggdrasilauthenticationservice;
         this.W = minecraftsessionservice;
         this.X = gameprofilerepository;
         this.Y = usercache;
-        this.universe = file;
+        // this.universe = file; // CraftBukkit
+
+        // SportBukkit - disable netty's resource leak detection
+        io.netty.util.ResourceLeakDetector.setEnabled(false);
+
         this.p = new ServerConnection(this);
         this.b = this.i();
-        this.convertable = new WorldLoaderServer(file, dataconvertermanager);
+        // this.convertable = new WorldLoaderServer(file); // CraftBukkit - moved to DedicatedServer.init
         this.dataConverterManager = dataconvertermanager;
+        this.dataConverterManager.a(DataConverterTypes.ENTITY, new org.bukkit.craftbukkit.DataInspectorEntityPassengers()); // SportBukkit
+        // CraftBukkit start
+        this.options = options;
+        // Try to see if we're actually running in a terminal, disable jline if not
+        if (System.console() == null && System.getProperty("jline.terminal") == null) {
+            System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+            Main.useJline = false;
+        }
+
+        try {
+            reader = new ConsoleReader(System.in, System.out);
+            reader.setExpandEvents(false); // Avoid parsing exceptions for uncommonly used event designators
+        } catch (Throwable e) {
+            try {
+                // Try again with jline disabled for Windows users without C++ 2008 Redistributable
+                System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+                System.setProperty("user.language", "en");
+                Main.useJline = false;
+                reader = new ConsoleReader(System.in, System.out);
+                reader.setExpandEvents(false);
+            } catch (IOException ex) {
+                LOGGER.warn((String) null, ex);
+            }
+        }
+        Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
+
+        this.serverThread = primaryThread = new Thread(this, "Server thread"); // Moved from main
     }
 
+    public abstract PropertyManager getPropertyManager();
+    // CraftBukkit end
+
     protected CommandDispatcher i() {
         return new CommandDispatcher(this);
     }
@@ -148,6 +227,7 @@
         this.a(s);
         this.b("menu.loadingLevel");
         this.worldServer = new WorldServer[3];
+        /* CraftBukkit start - Remove ticktime arrays and worldsettings
         this.i = new long[this.worldServer.length][100];
         IDataManager idatamanager = this.convertable.a(s, true);
 
@@ -171,36 +251,109 @@
             worlddata.a(s1);
             worldsettings = new WorldSettings(worlddata);
         }
+        */
+        int worldCount = 3;
 
-        for (int j = 0; j < this.worldServer.length; ++j) {
-            byte b0 = 0;
+        for (int j = 0; j < worldCount; ++j) {
+            WorldServer world;
+            byte dimension = 0;
 
             if (j == 1) {
-                b0 = -1;
+                if (getAllowNether()) {
+                    dimension = -1;
+                } else {
+                    continue;
+                }
             }
 
             if (j == 2) {
-                b0 = 1;
+                if (server.getAllowEnd()) {
+                    dimension = 1;
+                } else {
+                    continue;
+                }
             }
 
+            String worldType = org.bukkit.World.Environment.getEnvironment(dimension).toString().toLowerCase();
+            String name = (dimension == 0) ? s : s + "_" + worldType;
+
+            org.bukkit.generator.ChunkGenerator gen = this.server.getGenerator(name);
+            WorldSettings worldsettings = new WorldSettings(i, this.getGamemode(), this.getGenerateStructures(), this.isHardcore(), worldtype);
+            worldsettings.setGeneratorSettings(s2);
+
             if (j == 0) {
+                IDataManager idatamanager = new ServerNBTManager(server.getWorldContainer(), s1, true, this.dataConverterManager);
+                WorldData worlddata = idatamanager.getWorldData();
+                if (worlddata == null) {
+                    worlddata = new WorldData(worldsettings, s1);
+                }
+                worlddata.checkName(s1); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
                 if (this.V()) {
-                    this.worldServer[j] = (WorldServer) (new DemoWorldServer(this, idatamanager, worlddata, b0, this.methodProfiler)).b();
+                    world = (WorldServer) (new DemoWorldServer(this, idatamanager, worlddata, dimension, this.methodProfiler)).b();
                 } else {
-                    this.worldServer[j] = (WorldServer) (new WorldServer(this, idatamanager, worlddata, b0, this.methodProfiler)).b();
+                    world = (WorldServer) (new WorldServer(this, idatamanager, worlddata, dimension, this.methodProfiler, org.bukkit.World.Environment.getEnvironment(dimension), gen)).b();
                 }
 
-                this.worldServer[j].a(worldsettings);
+                world.a(worldsettings);
+                this.server.scoreboardManager = new org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager(this, world.getScoreboard());
+                this.server.overworld = world;
             } else {
-                this.worldServer[j] = (WorldServer) (new SecondaryWorldServer(this, idatamanager, b0, this.worldServer[0], this.methodProfiler)).b();
+                String dim = "DIM" + dimension;
+
+                File newWorld = new File(new File(name), dim);
+                File oldWorld = new File(new File(s), dim);
+
+                if ((!newWorld.isDirectory()) && (oldWorld.isDirectory())) {
+                    MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder required ----");
+                    MinecraftServer.LOGGER.info("Unfortunately due to the way that Minecraft implemented multiworld support in 1.6, Bukkit requires that you move your " + worldType + " folder to a new location in order to operate correctly.");
+                    MinecraftServer.LOGGER.info("We will move this folder for you, but it will mean that you need to move it back should you wish to stop using Bukkit in the future.");
+                    MinecraftServer.LOGGER.info("Attempting to move " + oldWorld + " to " + newWorld + "...");
+
+                    if (newWorld.exists()) {
+                        MinecraftServer.LOGGER.warn("A file or folder already exists at " + newWorld + "!");
+                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                    } else if (newWorld.getParentFile().mkdirs()) {
+                        if (oldWorld.renameTo(newWorld)) {
+                            MinecraftServer.LOGGER.info("Success! To restore " + worldType + " in the future, simply move " + newWorld + " to " + oldWorld);
+                            // Migrate world data too.
+                            try {
+                                com.google.common.io.Files.copy(new File(new File(s), "level.dat"), new File(new File(name), "level.dat"));
+                                org.apache.commons.io.FileUtils.copyDirectory(new File(new File(s), "data"), new File(new File(name), "data"));
+                            } catch (IOException exception) {
+                                MinecraftServer.LOGGER.warn("Unable to migrate world data.");
+                            }
+                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder complete ----");
+                        } else {
+                            MinecraftServer.LOGGER.warn("Could not move folder " + oldWorld + " to " + newWorld + "!");
+                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                        }
+                    } else {
+                        MinecraftServer.LOGGER.warn("Could not create path for " + newWorld + "!");
+                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                    }
+                }
+
+                IDataManager idatamanager = new ServerNBTManager(server.getWorldContainer(), name, true, this.dataConverterManager);
+                // world =, b0 to dimension, s1 to name, added Environment and gen
+                WorldData worlddata = idatamanager.getWorldData();
+                if (worlddata == null) {
+                    worlddata = new WorldData(worldsettings, name);
+                }
+                worlddata.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+                world = (WorldServer) new SecondaryWorldServer(this, idatamanager, dimension, this.worlds.get(0), this.methodProfiler, worlddata, org.bukkit.World.Environment.getEnvironment(dimension), gen).b();
             }
 
-            this.worldServer[j].addIWorldAccess(new WorldManager(this, this.worldServer[j]));
+            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(world.getWorld()));
+
+            world.addIWorldAccess(new WorldManager(this, world));
             if (!this.R()) {
-                this.worldServer[j].getWorldData().setGameType(this.getGamemode());
+                world.getWorldData().setGameType(this.getGamemode());
             }
-        }
 
+            worlds.add(world);
+            getPlayerList().setPlayerFileData(worlds.toArray(new WorldServer[worlds.size()]));
+        }
+        // CraftBukkit end
         this.v.setPlayerFileData(this.worldServer);
         this.a(this.getDifficulty());
         this.l();
@@ -216,25 +369,38 @@
         this.b("menu.generatingTerrain");
         boolean flag4 = false;
 
-        MinecraftServer.LOGGER.info("Preparing start region for level 0");
-        WorldServer worldserver = this.worldServer[0];
-        BlockPosition blockposition = worldserver.getSpawn();
-        long j = aw();
-
-        for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
-            for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
-                long i1 = aw();
-
-                if (i1 - j > 1000L) {
-                    this.a_("Preparing spawn area", i * 100 / 625);
-                    j = i1;
-                }
+        // CraftBukkit start - fire WorldLoadEvent and handle whether or not to keep the spawn in memory
+        for (int m = 0; m < worlds.size(); m++) {
+            WorldServer worldserver = this.worlds.get(m);
+            MinecraftServer.LOGGER.info("Preparing start region for level " + m + " (Seed: " + worldserver.getSeed() + ")");
+
+            if (!worldserver.getWorld().getKeepSpawnInMemory()) {
+                continue;
+            }
+
+            BlockPosition blockposition = worldserver.getSpawn();
+            long j = aw();
+            i = 0;
+
+            for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
+                for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
+                    long i1 = aw();
+
+                    if (i1 - j > 1000L) {
+                        this.a_("Preparing spawn area", i * 100 / 625);
+                        j = i1;
+                    }
 
-                ++i;
-                worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    ++i;
+                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                }
             }
         }
 
+        for (WorldServer world : this.worlds) {
+            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(world.getWorld()));
+        }
+        // CraftBukkit end
         this.t();
     }
 
@@ -274,14 +440,17 @@
     protected void t() {
         this.f = null;
         this.g = 0;
+        this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD); // CraftBukkit
     }
 
     protected void saveChunks(boolean flag) {
         WorldServer[] aworldserver = this.worldServer;
         int i = aworldserver.length;
 
-        for (int j = 0; j < i; ++j) {
-            WorldServer worldserver = aworldserver[j];
+        // CraftBukkit start
+        for (int j = 0; j < worlds.size(); ++j) {
+            WorldServer worldserver = worlds.get(j);
+            // CraftBukkit end
 
             if (worldserver != null) {
                 if (!flag) {
@@ -290,6 +459,7 @@
 
                 try {
                     worldserver.save(true, (IProgressUpdate) null);
+                    worldserver.saveLevel(); // CraftBukkit
                 } catch (ExceptionWorldConflict exceptionworldconflict) {
                     MinecraftServer.LOGGER.warn(exceptionworldconflict.getMessage());
                 }
@@ -298,8 +468,24 @@
 
     }
 
-    protected void stop() {
+    // CraftBukkit start
+    private boolean hasStopped = false;
+    private final Object stopLock = new Object();
+    // CraftBukkit end
+
+    public void stop() throws ExceptionWorldConflict { // CraftBukkit - added throws
+        // CraftBukkit start - prevent double stopping on multiple threads
+        synchronized(stopLock) {
+            if (hasStopped) return;
+            hasStopped = true;
+        }
+        // CraftBukkit end
         MinecraftServer.LOGGER.info("Stopping server");
+        // CraftBukkit start
+        if (this.server != null) {
+            this.server.disablePlugins();
+        }
+        // CraftBukkit end
         if (this.an() != null) {
             this.an().b();
         }
@@ -308,6 +494,7 @@
             MinecraftServer.LOGGER.info("Saving players");
             this.v.savePlayers();
             this.v.u();
+            try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
         }
 
         if (this.worldServer != null) {
@@ -329,12 +516,14 @@
             aworldserver = this.worldServer;
             i = aworldserver.length;
 
+            /* CraftBukkit start - Handled in saveChunks
             for (j = 0; j < i; ++j) {
                 worldserver = aworldserver[j];
                 if (worldserver != null) {
                     worldserver.saveLevel();
                 }
             }
+            // CraftBukkit end */
         }
 
         if (this.m.d()) {
@@ -357,52 +546,135 @@
 
     public void safeShutdown() {
         this.isRunning = false;
+        setSuspended(false); // SportBukkit
+    }
+
+    // SportBukkit start
+    public boolean isSuspended() {
+        return isRunning() && suspended.get();
+    }
+
+    public boolean canSuspend() {
+        return isRunning() && !p.hasClientConnections();
+    }
+
+    public boolean setSuspended(boolean suspend) {
+        if(suspend && !canSuspend()) return false;
+
+        if(suspended.compareAndSet(!suspend, suspend)) {
+            if(!isMainThread() && !suspend) {
+                synchronized(suspended) {
+                    suspended.notifyAll();
+                }
+            }
+            return true;
+        }
+
+        return false;
+    }
+
+    public @Nullable Instant suspendedAt() {
+        return suspendedAt;
+    }
+
+    public int interruptions() {
+        return interruptions;
+    }
+
+    private boolean doSuspension() {
+        if(isSuspended()) {
+            server.eventBus().callEvent(new ServerSuspendEvent(), (EventBody<ServerSuspendEvent, RuntimeException>) ev -> { // Cast needed due to javac bug
+                server.getLogger().info("Suspending server");
+                suspendedAt = Instant.now();
+                interruptions = 0;
+
+                if(watchdogThread != null) watchdogThread.interrupt();
+
+                while(isSuspended()) {
+                    processTasks(); // Empty the task queue
+                    synchronized(suspended) {
+                        if(isSuspended()) { // Check suspended state again, in case a task resumed
+                            try { suspended.wait(); }
+                            catch(InterruptedException ignored) {}
+                            interruptions++;
+                        }
+                    }
+                }
+
+                if(watchdogThread != null) watchdogThread.interrupt();
+
+                interruptions = 0;
+                suspendedAt = null;
+                setLastTickStart(realTimeMillis());
+                server.getLogger().info("Resuming server");
+            });
+            return true;
+        }
+        return false;
     }
 
+    public void interrupt() {
+        if(!isMainThread()) {
+            synchronized(suspended) {
+                if(suspended.get()) {
+                    suspended.notifyAll();
+                }
+            }
+        }
+    }
+
+    private static double calcTps(double avg, double exp, double tps) {
+        return ( avg * exp ) + ( tps * ( 1 - exp ) );
+    }
+    // SportBukkit End
+
     public void run() {
         try {
             if (this.init()) {
-                this.ab = aw();
-                long i = 0L;
-
                 this.q.setMOTD(new ChatComponentText(this.motd));
                 this.q.setServerInfo(new ServerPing.ServerData("1.12.2", 340));
                 this.a(this.q);
 
-                while (this.isRunning) {
-                    long j = aw();
-                    long k = j - this.ab;
-
-                    if (k > 2000L && this.ab - this.R >= 15000L) {
-                        MinecraftServer.LOGGER.warn("Can\'t keep up! Did the system time change, or is the server overloaded? Running {}ms behind, skipping {} tick(s)", Long.valueOf(k), Long.valueOf(k / 50L));
-                        k = 2000L;
-                        this.R = this.ab;
-                    }
-
-                    if (k < 0L) {
-                        MinecraftServer.LOGGER.warn("Time ran backwards! Did the system time change?");
-                        k = 0L;
-                    }
+                // SportBukkit start
+                Arrays.fill( recentTps, 20 );
+                long lastTick = System.nanoTime(), catchupTime = 0, curTime, tickSection = lastTick;
 
-                    i += k;
-                    this.ab = j;
-                    if (this.worldServer[0].everyoneDeeplySleeping()) {
-                        this.C();
-                        i = 0L;
+                while (this.isRunning) {
+                    setLastTickStart(realTimeMillis());
+                    curTime = System.nanoTime();
+                    final long wait = TICK_TIME - (curTime - lastTick) - catchupTime;
+                    if(wait < 0) {
+                        catchupTime = Math.min(1000000000, Math.abs(wait));
                     } else {
-                        while (i > 50L) {
-                            i -= 50L;
-                            this.C();
+                        catchupTime = 0;
+                        if(doSuspension()) {
+                            tickSection = lastTick = curTime - TICK_TIME;
+                        } else {
+                            Thread.sleep(wait / 1000000);
                         }
+                        catchupTime = 0;
+                        continue;
+                    }
+                    lastTick = curTime;
+
+                    if ( MinecraftServer.currentTick++ % SAMPLE_INTERVAL == 0 ) {
+                        double currentTps = 1E9 / ( curTime - tickSection ) * SAMPLE_INTERVAL;
+                        recentTps[0] = calcTps( recentTps[0], 0.92, currentTps ); // 1/exp(5sec/1min)
+                        recentTps[1] = calcTps( recentTps[1], 0.9835, currentTps ); // 1/exp(5sec/5min)
+                        recentTps[2] = calcTps( recentTps[2], 0.9945, currentTps ); // 1/exp(5sec/15min)
+                        tickSection = curTime;
                     }
 
-                    Thread.sleep(Math.max(1L, 50L - i));
+                    this.runTick();
                     this.Q = true;
                 }
             } else {
-                this.a((CrashReport) null);
+                // CraftBukkit - if init fails, stop the server
+                // this.a((CrashReport) null);
+                this.abnormalTermination = true; // SportBukkit
             }
         } catch (Throwable throwable) {
+            this.abnormalTermination = true; // SportBukkit
             MinecraftServer.LOGGER.error("Encountered an unexpected exception", throwable);
             CrashReport crashreport = null;
 
@@ -428,6 +700,12 @@
             } catch (Throwable throwable1) {
                 MinecraftServer.LOGGER.error("Exception stopping the server", throwable1);
             } finally {
+                // CraftBukkit start - Restore terminal to original settings
+                try {
+                    reader.getTerminal().restore();
+                } catch (Exception ignored) {
+                }
+                // CraftBukkit end
                 this.B();
             }
 
@@ -471,7 +749,8 @@
 
     public void B() {}
 
-    protected void C() {
+    protected void runTick() throws ExceptionWorldConflict { C(); } // SportBukkit - alias
+    protected void C() throws ExceptionWorldConflict { // CraftBukkit - added throws
         long i = System.nanoTime();
 
         ++this.ticks;
@@ -497,7 +776,7 @@
             this.q.b().a(agameprofile);
         }
 
-        if (this.ticks % 900 == 0) {
+        if (autosavePeriod > 0 && this.ticks % autosavePeriod == 0) { // CraftBukkit
             this.methodProfiler.a("save");
             this.v.savePlayers();
             this.saveChunks(true);
@@ -508,11 +787,11 @@
         this.h[this.ticks % 100] = System.nanoTime() - i;
         this.methodProfiler.b();
         this.methodProfiler.a("snooper");
-        if (!this.m.d() && this.ticks > 100) {
+        if (getSnooperEnabled() && !this.m.d() && this.ticks > 100) { // SportBukkit - Disable snooper
             this.m.a();
         }
 
-        if (this.ticks % 6000 == 0) {
+        if (getSnooperEnabled() && this.ticks % 6000 == 0) { // SportBukkit - Disable snooper
             this.m.b();
         }
 
@@ -521,33 +800,61 @@
     }
 
     public void D() {
+        this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
         this.methodProfiler.a("jobs");
         Queue queue = this.j;
 
+        // SportBukkit start - don't lock the task queue while running tasks
+        processTasks();
+        this.server.checkEmpty();
+        if(suspended.get()) return;
+        /*
         synchronized (this.j) {
             while (!this.j.isEmpty()) {
                 SystemUtils.a((FutureTask) this.j.poll(), MinecraftServer.LOGGER);
             }
         }
+        */
+        // SportBukkit end
 
         this.methodProfiler.c("levels");
 
+        // CraftBukkit start
+        // Run tasks that are waiting on processing
+        // SportBukkit - use Mojang's task queue
+        //while (!processQueue.isEmpty()) {
+        //    processQueue.remove().run();
+        //}
+
+        org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
+
+        // Send time updates to everyone, it will get the right time from the world the player is in.
+        if (this.ticks % 20 == 0) {
+            for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
+                EntityPlayer entityplayer = (EntityPlayer) this.getPlayerList().players.get(i);
+                entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(entityplayer.world.getTime(), entityplayer.getPlayerTime(), entityplayer.world.getGameRules().getBoolean("doDaylightCycle"))); // Add support for per player time
+            }
+        }
+
         int i;
 
-        for (i = 0; i < this.worldServer.length; ++i) {
+        for (i = 0; i < this.worlds.size(); ++i) { // CraftBukkit
             long j = System.nanoTime();
 
-            if (i == 0 || this.getAllowNether()) {
-                WorldServer worldserver = this.worldServer[i];
+            // if (i == 0 || this.getAllowNether()) {
+                WorldServer worldserver = this.worlds.get(i);
+            if(!worldserver.getWorld().checkTicking()) continue; // SportBukkit
 
                 this.methodProfiler.a(() -> {
                     return worldserver.getWorldData().getName();
                 });
+                /* Drop global time updates
                 if (this.ticks % 20 == 0) {
                     this.methodProfiler.a("timeSync");
                     this.v.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean("doDaylightCycle"))), worldserver.worldProvider.getDimensionManager().getDimensionID());
                     this.methodProfiler.b();
                 }
+                // CraftBukkit end */
 
                 this.methodProfiler.a("tick");
 
@@ -574,9 +881,9 @@
                 worldserver.getTracker().updatePlayers();
                 this.methodProfiler.b();
                 this.methodProfiler.b();
-            }
+            // } // CraftBukkit
 
-            this.i[i][this.ticks % 100] = System.nanoTime() - j;
+            // this.i[i][this.ticks % 100] = System.nanoTime() - j; // CraftBukkit
         }
 
         this.methodProfiler.c("connection");
@@ -602,10 +909,11 @@
         this.o.add(itickable);
     }
 
-    public static void main(String[] astring) {
+    public static void main(final OptionSet options) { // CraftBukkit - replaces main(String[] astring)
         DispenserRegistry.c();
 
         try {
+            /* CraftBukkit start - Replace everything
             boolean flag = true;
             String s = null;
             String s1 = ".";
@@ -650,13 +958,16 @@
                     ++j;
                 }
             }
+            */ // CraftBukkit end
 
+            String s1 = "."; // PAIL?
             YggdrasilAuthenticationService yggdrasilauthenticationservice = new YggdrasilAuthenticationService(Proxy.NO_PROXY, UUID.randomUUID().toString());
             MinecraftSessionService minecraftsessionservice = yggdrasilauthenticationservice.createMinecraftSessionService();
             GameProfileRepository gameprofilerepository = yggdrasilauthenticationservice.createProfileRepository();
             UserCache usercache = new UserCache(gameprofilerepository, new File(s1, MinecraftServer.a.getName()));
-            final DedicatedServer dedicatedserver = new DedicatedServer(new File(s1), DataConverterRegistry.a(), yggdrasilauthenticationservice, minecraftsessionservice, gameprofilerepository, usercache);
+            final DedicatedServer dedicatedserver = new DedicatedServer(options, DataConverterRegistry.a(), yggdrasilauthenticationservice, minecraftsessionservice, gameprofilerepository, usercache);
 
+            /* CraftBukkit start
             if (s != null) {
                 dedicatedserver.i(s);
             }
@@ -687,15 +998,37 @@
                     dedicatedserver.stop();
                 }
             });
+            */
+
+            if (options.has("port")) {
+                int port = (Integer) options.valueOf("port");
+                if (port > 0) {
+                    dedicatedserver.setPort(port);
+                }
+            }
+
+            if (options.has("universe")) {
+                dedicatedserver.universe = (File) options.valueOf("universe");
+            }
+
+            if (options.has("world")) {
+                dedicatedserver.setWorld((String) options.valueOf("world"));
+            }
+
+            dedicatedserver.primaryThread.start();
+            // CraftBukkit end
         } catch (Exception exception) {
             MinecraftServer.LOGGER.fatal("Failed to start the minecraft server", exception);
+            System.exit(1); // Sportbukkit
         }
 
     }
 
     public void F() {
+        /* CraftBukkit start - prevent abuse
         this.serverThread = new Thread(this, "Server thread");
         this.serverThread.start();
+        // CraftBukkit end */
     }
 
     public File d(String s) {
@@ -711,7 +1044,14 @@
     }
 
     public WorldServer getWorldServer(int i) {
-        return i == -1 ? this.worldServer[1] : (i == 1 ? this.worldServer[2] : this.worldServer[0]);
+        // CraftBukkit start
+        for (WorldServer world : worlds) {
+            if (world.dimension == i) {
+                return world;
+            }
+        }
+        return worlds.get(0);
+        // CraftBukkit end
     }
 
     public String getVersion() {
@@ -735,7 +1075,7 @@
     }
 
     public boolean isDebugging() {
-        return false;
+        return this.getPropertyManager().getBoolean("debug", false); // CraftBukkit - don't hardcode
     }
 
     public void g(String s) {
@@ -750,7 +1090,7 @@
     }
 
     public String getServerModName() {
-        return "vanilla";
+        return server.getName(); // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -779,6 +1119,7 @@
     }
 
     public List<String> tabCompleteCommand(ICommandListener icommandlistener, String s, @Nullable BlockPosition blockposition, boolean flag) {
+        /* CraftBukkit start - Allow tab-completion of Bukkit commands
         ArrayList arraylist = Lists.newArrayList();
         boolean flag1 = s.startsWith("/");
 
@@ -821,10 +1162,13 @@
 
             return arraylist;
         }
+        */
+        return server.tabComplete(icommandlistener, s, blockposition, flag);
+        // CraftBukkit end
     }
 
     public boolean M() {
-        return this.universe != null;
+        return true; // CraftBukkit
     }
 
     public String getName() {
@@ -832,7 +1176,7 @@
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
-        MinecraftServer.LOGGER.info(ichatbasecomponent.toPlainText());
+        this.console.sendMessage(ichatbasecomponent.toPlainText()); // SportBukkit - we want coloured and pretty messages too!
     }
 
     public boolean a(int i, String s) {
@@ -847,6 +1191,7 @@
         return this.I;
     }
 
+    public int getConfiguredPort() { return this.P(); } // SportBukkit - alias for following method
     public int P() {
         return this.u;
     }
@@ -880,11 +1225,13 @@
     }
 
     public void a(EnumDifficulty enumdifficulty) {
-        WorldServer[] aworldserver = this.worldServer;
-        int i = aworldserver.length;
+        // CraftBukkit start
+        // WorldServer[] aworldserver = this.worldServer;
+        int i = this.worlds.size();
 
         for (int j = 0; j < i; ++j) {
-            WorldServer worldserver = aworldserver[j];
+            WorldServer worldserver = this.worlds.get(j);
+            // CraftBukkit end
 
             if (worldserver != null) {
                 if (worldserver.getWorldData().isHardcore()) {
@@ -951,13 +1298,11 @@
         int i = 0;
 
         if (this.worldServer != null) {
-            WorldServer[] aworldserver = this.worldServer;
-            int j = aworldserver.length;
-
-            for (int k = 0; k < j; ++k) {
-                WorldServer worldserver = aworldserver[k];
-
+            // CraftBukkit start
+            for (int j = 0; j < this.worlds.size(); ++j) {
+                WorldServer worldserver = this.worlds.get(j);
                 if (worldserver != null) {
+                    // CraftBukkit end
                     WorldData worlddata = worldserver.getWorldData();
 
                     mojangstatisticsgenerator.a("world[" + i + "][dimension]", Integer.valueOf(worldserver.worldProvider.getDimensionManager().getDimensionID()));
@@ -990,7 +1335,7 @@
     public abstract boolean aa();
 
     public boolean getOnlineMode() {
-        return this.onlineMode;
+        return server.getOnlineMode(); // CraftBukkit
     }
 
     public void setOnlineMode(boolean flag) {
@@ -1070,17 +1415,14 @@
     }
 
     public void setGamemode(EnumGamemode enumgamemode) {
-        WorldServer[] aworldserver = this.worldServer;
-        int i = aworldserver.length;
-
-        for (int j = 0; j < i; ++j) {
-            WorldServer worldserver = aworldserver[j];
-
-            worldserver.getWorldData().setGameType(enumgamemode);
+        // CraftBukkit start
+        for (int i = 0; i < this.worlds.size(); ++i) {
+            worlds.get(i).getWorldData().setGameType(enumgamemode);
         }
 
     }
 
+    public ServerConnection getServerConnection() { return this.an(); } // SportBukkit - alias for following method
     public ServerConnection an() {
         return this.p;
     }
@@ -1100,7 +1442,7 @@
     }
 
     public World getWorld() {
-        return this.worldServer[0];
+        return this.worlds.get(0); // CraftBukkit
     }
 
     public int getSpawnProtection() {
@@ -1123,6 +1465,7 @@
         return this.e;
     }
 
+    public static long realTimeMillis() { return aw(); } // SportBukkit - alias
     public static long aw() {
         return System.currentTimeMillis();
     }
@@ -1160,8 +1503,10 @@
         WorldServer[] aworldserver = this.worldServer;
         int i = aworldserver.length;
 
-        for (int j = 0; j < i; ++j) {
-            WorldServer worldserver = aworldserver[j];
+        // CraftBukkit start
+        for (int j = 0; j < worlds.size(); ++j) {
+            WorldServer worldserver = worlds.get(j);
+            // CraftBukkit end
 
             if (worldserver != null) {
                 Entity entity = worldserver.getEntity(uuid);
@@ -1176,7 +1521,7 @@
     }
 
     public boolean getSendCommandFeedback() {
-        return this.worldServer[0].getGameRules().getBoolean("sendCommandFeedback");
+        return worlds.get(0).getGameRules().getBoolean("sendCommandFeedback");
     }
 
     public MinecraftServer C_() {
@@ -1189,12 +1534,13 @@
 
     public <V> ListenableFuture<V> a(Callable<V> callable) {
         Validate.notNull(callable);
-        if (!this.isMainThread() && !this.isStopped()) {
+        if (!this.isMainThread()) { // CraftBukkit && !this.isStopped()) {
             ListenableFutureTask listenablefuturetask = ListenableFutureTask.create(callable);
             Queue queue = this.j;
 
             synchronized (this.j) {
                 this.j.add(listenablefuturetask);
+                interrupt(); // SportBukkit
                 return listenablefuturetask;
             }
         } else {
@@ -1215,6 +1561,48 @@
         return Thread.currentThread() == this.serverThread;
     }
 
+    // SportBukkit start
+    public void addMainThreadTask(FutureTask<?> task) {
+        addMainThreadTask(false, task);
+    }
+
+    public void addMainThreadTask(boolean priority, FutureTask<?> task) {
+        synchronized(taskQueue) {
+            if(priority) {
+                taskQueue.addFirst(task);
+            } else {
+                taskQueue.addLast(task);
+            }
+        }
+        interrupt();
+    }
+
+    public void addMainThreadTask(Runnable task) {
+        addMainThreadTask(false, task);
+    }
+
+    public <T> ListenableFuture<T> addMainThreadTask(boolean priority, Runnable task) {
+        final ListenableFutureTask<T> future = ListenableFutureTask.create(task, null);
+        addMainThreadTask(priority, future);
+        return future;
+    }
+
+    protected void processTasks() {
+        if(!isMainThread()) throw new IllegalStateException("Tasks must be processed on the main thread");
+        for(;;) {
+            final FutureTask<?> task;
+            synchronized(taskQueue) {
+                task = taskQueue.poll();
+            }
+            if(task == null) {
+                break;
+            } else {
+                SystemUtils.a(task, MinecraftServer.LOGGER);
+            }
+        }
+    }
+    // SportBukkit end
+
     public int aG() {
         return 256;
     }
@@ -1232,17 +1620,17 @@
     }
 
     public AdvancementDataWorld getAdvancementData() {
-        return this.worldServer[0].z();
+        return this.worlds.get(0).z(); // CraftBukkit
     }
 
     public CustomFunctionData aL() {
-        return this.worldServer[0].A();
+        return this.worlds.get(0).A(); // CraftBukkit
     }
 
     public void reload() {
         if (this.isMainThread()) {
             this.getPlayerList().savePlayers();
-            this.worldServer[0].getLootTableRegistry().reload();
+            this.worlds.get(0).getLootTableRegistry().reload(); // CraftBukkit
             this.getAdvancementData().reload();
             this.aL().f();
             this.getPlayerList().reload();
@@ -1251,4 +1639,11 @@
         }
 
     }
+
+    // CraftBukkit start
+    @Deprecated
+    public static MinecraftServer getServer() {
+        return (Bukkit.getServer() instanceof CraftServer) ? ((CraftServer) Bukkit.getServer()).getServer() : null;
+    }
+    // CraftBukkit end
 }
